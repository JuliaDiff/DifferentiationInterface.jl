var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#DifferentiationInterfaceTest","page":"API reference","title":"DifferentiationInterfaceTest","text":"DifferentiationInterfaceTest\n\nTesting and benchmarking utilities for automatic differentiation in Julia.\n\n\n\n\n\n","category":"module"},{"location":"api/#Entry-points","page":"API reference","title":"Entry points","text":"","category":"section"},{"location":"api/#DifferentiationInterfaceTest.Scenario","page":"API reference","title":"DifferentiationInterfaceTest.Scenario","text":"Scenario{op,pl_op,pl_fun}\n\nStore a testing scenario composed of a function and its input + output for a given operator.\n\nThis generic type should never be used directly: use the specific constructor corresponding to the operator you want to test, or a predefined list of scenarios.\n\nType parameters\n\nop: one  of :pushforward, :pullback, :derivative, :gradient, :jacobian,:second_derivative, :hvp, :hessian\npl_op: either :in (for op!(f, result, backend, x)) or :out (for result = op(f, backend, x))\npl_fun: either :in (for f!(y, x)) or :out (for y = f(x))\n\nConstructors\n\nScenario{op,pl_op}(\n    f, x, [t], contexts...;\n    prep_args, res1, res2, name\n)\n\nScenario{op,pl_op}(\n    f!, y, x, [t,] contexts...;\n    prep_args, res1, res2, name\n)\n\nDefault values:\n\nprep_args = the result of zero applied to each execution argument\nres1 = res2 = nothing\nname = nothing\n\nFields\n\nf::Any: function f (if pl_fun==:out) or f! (if pl_fun==:in) to apply\ny::Any: primal output\nx::Any: primal input\nt::Union{Nothing, NTuple{N, T} where {N, T}}: tangents (if applicable)\ncontexts::Tuple: contexts (if applicable)\nres1::Any: first-order result of the operator (if applicable)\nres2::Any: second-order result of the operator (if applicable)\nprep_args::NamedTuple: named tuple of arguments passed to preparation, without the function - the required keys are a subset of (; y, x, t, contexts) depending on the operator\nname::Union{Nothing, String}: name of the scenario for display in test sets and dataframes\n\n\n\n\n\n","category":"type"},{"location":"api/#DifferentiationInterfaceTest.compute_results","page":"API reference","title":"DifferentiationInterfaceTest.compute_results","text":"compute_results(scen::Scenario, backend::AbstractADType)\n\nReturn a scenario identical to scen but where the first- and second-order results res1 and res2 have been computed with the given differentiation backend.\n\nUseful for comparison of outputs between backends.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.test_differentiation","page":"API reference","title":"DifferentiationInterfaceTest.test_differentiation","text":"test_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType};\n    ...\n) -> Union{Nothing, DataFrames.DataFrame}\ntest_differentiation(\n    backends::Vector{<:ADTypes.AbstractADType},\n    scenarios::Vector{<:Scenario};\n    testset_name,\n    correctness,\n    type_stability,\n    allocations,\n    benchmark,\n    excluded,\n    detailed,\n    logging,\n    isapprox,\n    atol,\n    rtol,\n    scenario_intact,\n    sparsity,\n    reprepare,\n    ignored_modules,\n    function_filter,\n    skip_allocations,\n    count_calls,\n    benchmark_test,\n    benchmark_seconds,\n    benchmark_aggregation,\n    adaptive_batchsize\n) -> Union{Nothing, DataFrames.DataFrame}\n\n\nApply a list of backends on a list of scenarios, running a variety of different tests and/or benchmarks.\n\nReturn\n\nThis function always creates and runs a @testset, though its contents may vary.\n\nif benchmark == :none, it returns nothing.\nif benchmark != :none, it returns a DataFrame of benchmark results, whose columns correspond to the fields of DifferentiationBenchmarkDataRow.\n\nPositional arguments\n\nbackends::Vector{<:AbstractADType}: the backends to test\nscenarios::Vector{<:Scenario}: the scenarios on which to test these backends. Defaults to a standard set of first- and second-order scenarios, whose contents are not part of the public API and may change without notice.\n\nKeyword arguments\n\ntestset_name=nothing: how to display the test set\n\nTest categories:\n\ncorrectness=true: whether to compare the differentiation results with the theoretical values specified in each scenario\ntype_stability=:none: whether (and how) to check type stability of operators with JET.jl.\nallocations=:none: whether (and how) to check allocations inside operators with AllocCheck.jl\nbenchmark=:none: whether (and how) to benchmark operators with Chairmarks.jl\n\nFor type_stability, allocations and benchmark, the possible values are :none, :prepared or :full. Each setting tests/benchmarks a different subset of calls:\n\nkwarg prepared operator unprepared operator preparation\n:none no no no\n:prepared yes no no\n:full yes yes yes\n\nMisc options:\n\nexcluded::Vector{Symbol}: list of operators to exclude, such as FIRST_ORDER or SECOND_ORDER\ndetailed=false: whether to create a detailed or condensed testset\nlogging=false: whether to log progress\n\nCorrectness options:\n\nisapprox=isapprox: function used to compare objects approximately, with the standard signature isapprox(x, y; atol, rtol)\natol=0: absolute precision for correctness testing (when comparing to the reference outputs)\nrtol=1e-3: relative precision for correctness testing (when comparing to the reference outputs)\nscenario_intact=true: whether to check that the scenario remains unchanged after the operators are applied\nsparsity=false: whether to check sparsity patterns for Jacobians / Hessians\nreprepare::Bool=true: whether to modify preparation before testing when the preparation arguments have the wrong size\n\nType stability options:\n\nignored_modules=nothing: list of modules that JET.jl should ignore\nfunction_filter: filter for functions that JET.jl should ignore (with a reasonable default)\n\nBenchmark options:\n\ncount_calls=true: whether to also count function calls during benchmarking\nbenchmark_test=true: whether to include tests which succeed iff benchmark doesn't error\nbenchmark_seconds=1: how long to run each benchmark for\nbenchmark_aggregation=minimum: function used to aggregate sample measurements\n\nBatch size options\n\nadaptive_batchsize=true: whether to cap the backend's preset batch size (when it exists) to prevent errors on small inputs\n\n\n\n\n\ntest_differentiation(\n    backend::ADTypes.AbstractADType,\n    args...;\n    kwargs...\n) -> Union{Nothing, DataFrames.DataFrame}\n\n\nShortcut for a single backend.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.benchmark_differentiation","page":"API reference","title":"DifferentiationInterfaceTest.benchmark_differentiation","text":"benchmark_differentiation(\n    backends,\n    scenarios::Vector{<:Scenario};\n    testset_name,\n    benchmark,\n    excluded,\n    logging,\n    count_calls,\n    benchmark_test,\n    benchmark_seconds,\n    benchmark_aggregation,\n    adaptive_batchsize\n) -> Union{Nothing, DataFrames.DataFrame}\n\n\nShortcut for test_differentiation with only benchmarks and no correctness or type stability checks.\n\nSpecifying the set of scenarios is mandatory for this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Utilities","page":"API reference","title":"Utilities","text":"","category":"section"},{"location":"api/#DifferentiationInterfaceTest.FIRST_ORDER","page":"API reference","title":"DifferentiationInterfaceTest.FIRST_ORDER","text":"FIRST_ORDER = [:pushforward, :pullback, :derivative, :gradient, :jacobian]\n\nList of all first-order operators, to facilitate exclusion during tests.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DifferentiationInterfaceTest.SECOND_ORDER","page":"API reference","title":"DifferentiationInterfaceTest.SECOND_ORDER","text":"SECOND_ORDER = [:hvp, :second_derivative, :hessian]\n\nList of all second-order operators, to facilitate exclusion during tests.\n\n\n\n\n\n","category":"constant"},{"location":"api/#DifferentiationInterfaceTest.DifferentiationBenchmarkDataRow","page":"API reference","title":"DifferentiationInterfaceTest.DifferentiationBenchmarkDataRow","text":"DifferentiationBenchmarkDataRow\n\nAd-hoc storage type for differentiation benchmarking results.\n\nFields\n\nbackend::ADTypes.AbstractADType: backend used for benchmarking\nscenario::Scenario: scenario used for benchmarking\noperator::Symbol: differentiation operator used for benchmarking, e.g. :gradient or :hessian\nprepared::Union{Nothing, Bool}: whether the operator had been prepared\ncalls::Int64: number of calls to the differentiated function for one call to the operator\nsamples::Int64: number of benchmarking samples taken\nevals::Int64: number of evaluations used for averaging in each sample\ntime::Any: aggregated runtime over all samples, in seconds\nallocs::Any: aggregated number of allocations over all samples\nbytes::Any: aggregated memory allocated over all samples, in bytes\ngc_fraction::Any: aggregated fraction of time spent in garbage collection over all samples, between 0.0 and 1.0\ncompile_fraction::Any: aggregated fraction of time spent compiling over all samples, between 0.0 and 1.0\n\nSee the documentation of Chairmarks.jl for more details on the measurement fields.\n\n\n\n\n\n","category":"type"},{"location":"api/#Internals","page":"API reference","title":"Internals","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"This is not part of the public API.","category":"page"},{"location":"api/#Base.zero-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"Base.zero","text":"zero(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the first- and second-order results which are set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.allocfree_scenarios-Tuple{}","page":"API reference","title":"DifferentiationInterfaceTest.allocfree_scenarios","text":"allocfree_scenarios()\n\nCreate a vector of Scenarios with functions that do not allocate.\n\nwarning: Warning\nAt the moment, second-order scenarios are excluded.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.batchify-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.batchify","text":"batchify(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the tangents tang and associated results res1 / res2, which are duplicated (batch mode).\n\nOnly works if scen is a pushforward, pullback or hvp scenario.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.cachify-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.cachify","text":"cachify(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the function f, which is made to accept an additional cache argument to store the result before it is returned.\n\nIf tup=true the cache is a tuple of arrays, otherwise just an array.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.change_function-Union{Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}, Tuple{Scenario{op, pl_op, pl_fun}, Any}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.change_function","text":"change_function(scen::Scenario, new_f)\n\nReturn a new Scenario identical to scen except for the function f which is changed to new_f.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.closurify-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.closurify","text":"closurify(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the function f which is made to close over differentiable data.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.complex_scenarios-Tuple{}","page":"API reference","title":"DifferentiationInterfaceTest.complex_scenarios","text":"complex_scenarios()\n\nCreate a vector of first-order Scenarios with complex-valued array types and holomorphic functions only.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.complex_sparse_scenarios-Tuple{}","page":"API reference","title":"DifferentiationInterfaceTest.complex_sparse_scenarios","text":"complex_sparse_scenarios()\n\nCreate a vector of Jacobian Scenarios with complex-valued array types and holomorphic functions only.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.component_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.component_scenarios","text":"component_scenarios()\n\nCreate a vector of Scenarios with component array types from ComponentArrays.jl.\n\nwarning: Warning\nThis function requires ComponentArrays.jl to be loaded (it is implemented in a package extension).\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.constantify-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.constantify","text":"constantify(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the function f, which is made to accept an additional constant argument by which the output is multiplied. The output and result fields are updated accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.constantorcachify-Union{Tuple{Scenario{op, pl_op, pl_fun}}, Tuple{pl_fun}, Tuple{pl_op}, Tuple{op}} where {op, pl_op, pl_fun}","page":"API reference","title":"DifferentiationInterfaceTest.constantorcachify","text":"constantorcachify(scen::Scenario)\n\nReturn a new Scenario identical to scen except for the function f, which is made to accept an additional \"constant or cache\" argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.default_scenarios-Tuple{}","page":"API reference","title":"DifferentiationInterfaceTest.default_scenarios","text":"default_scenarios()\n\nCreate a vector of Scenarios with standard array types.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.flux_isapprox","page":"API reference","title":"DifferentiationInterfaceTest.flux_isapprox","text":"flux_isapprox(x, y; atol, rtol)\n\nApproximate comparison function to use in correctness tests with gradients of Flux.jl networks.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.flux_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.flux_scenarios","text":"flux_scenarios(rng=Random.default_rng())\n\nCreate a vector of Scenarios with neural networks from Flux.jl.\n\nwarning: Warning\nThis function requires FiniteDifferences.jl and Flux.jl to be loaded (it is implemented in a package extension).\n\ndanger: Danger\nThese scenarios are still experimental and not part of the public API. Their ground truth values are computed with finite differences, and thus subject to imprecision.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.gpu_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.gpu_scenarios","text":"gpu_scenarios()\n\nCreate a vector of Scenarios with GPU array types from JLArrays.jl.\n\nwarning: Warning\nThis function requires JLArrays.jl to be loaded (it is implemented in a package extension).\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.lux_isapprox","page":"API reference","title":"DifferentiationInterfaceTest.lux_isapprox","text":"lux_isapprox(x, y; atol, rtol)\n\nApproximate comparison function to use in correctness tests with gradients of Lux.jl networks.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.lux_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.lux_scenarios","text":"lux_scenarios(rng=Random.default_rng())\n\nCreate a vector of Scenarios with neural networks from Lux.jl.\n\nwarning: Warning\nThis function requires ComponentArrays.jl, ForwardDiff.jl, Lux.jl and LuxTestUtils.jl to be loaded (it is implemented in a package extension).\n\ndanger: Danger\nThese scenarios are still experimental and not part of the public API.\n\n\n\n\n\n","category":"function"},{"location":"api/#DifferentiationInterfaceTest.sparse_scenarios-Tuple{}","page":"API reference","title":"DifferentiationInterfaceTest.sparse_scenarios","text":"sparse_scenarios()\n\nCreate a vector of Scenarios with sparse array types, focused on sparse Jacobians and Hessians.\n\n\n\n\n\n","category":"method"},{"location":"api/#DifferentiationInterfaceTest.static_scenarios","page":"API reference","title":"DifferentiationInterfaceTest.static_scenarios","text":"static_scenarios()\n\nCreate a vector of Scenarios with static array types from StaticArrays.jl.\n\nwarning: Warning\nThis function requires StaticArrays.jl to be loaded (it is implemented in a package extension).\n\n\n\n\n\n","category":"function"},{"location":"#DifferentiationInterfaceTest","page":"Home","title":"DifferentiationInterfaceTest","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package Docs\nDifferentiationInterface (Image: Stable)     (Image: Dev)\nDifferentiationInterfaceTest (Image: Stable) (Image: Dev)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Testing and benchmarking utilities for automatic differentiation (AD) in Julia, based on DifferentiationInterface.","category":"page"},{"location":"#Goal","page":"Home","title":"Goal","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Make it easy to know, for a given function:","category":"page"},{"location":"","page":"Home","title":"Home","text":"which AD backends can differentiate it\nhow fast they can do it","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Definition of custom test scenarios\nCorrectness tests\nType stability tests\nCount calls to the function\nBenchmark runtime and allocations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the stable version of the package, run the following code in a Julia REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(\"DifferentiationInterfaceTest\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install the development version, run this instead:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\n\nPkg.add(;\n    url=\"https://github.com/JuliaDiff/DifferentiationInterface.jl\",\n    subdir=\"DifferentiationInterface\",\n)\n\nPkg.add(;\n    url=\"https://github.com/JuliaDiff/DifferentiationInterface.jl\",\n    subdir=\"DifferentiationInterfaceTest\",\n)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We present a typical workflow with DifferentiationInterfaceTest.jl, building on the tutorial of the DifferentiationInterface.jl documentation (which we encourage you to read first).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using DifferentiationInterface, DifferentiationInterfaceTest\nusing ForwardDiff: ForwardDiff\nusing Zygote: Zygote","category":"page"},{"location":"tutorial/#Introduction","page":"Tutorial","title":"Introduction","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The AD backends we want to compare are ForwardDiff.jl and Zygote.jl.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"backends = [AutoForwardDiff(), AutoZygote()]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To do that, we are going to take gradients of a simple function:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"f(x::AbstractArray) = sum(sin, x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Of course we know the true gradient mapping:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"∇f(x::AbstractArray) = cos.(x)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DifferentiationInterfaceTest.jl relies with so-called Scenarios, in which you encapsulate the information needed for your test:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"the operator category (here :gradient)\nthe behavior of the operator (either :in or :out of place)\nthe function f\nthe input x of the function f (and possible tangents or contexts)\nthe reference first-order result res1 (and possible second-order result res2) of the operator\nthe arguments prep_args passed during preparation","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"xv = rand(Float32, 3)\nxm = rand(Float64, 3, 2)\nscenarios = [\n    Scenario{:gradient,:out}(f, xv; res1=∇f(xv)),\n    Scenario{:gradient,:out}(f, xm; res1=∇f(xm)),\n];\nnothing  # hide","category":"page"},{"location":"tutorial/#Testing","page":"Tutorial","title":"Testing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The main entry point for testing is the function test_differentiation. It has many options, but the main ingredients are the following:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"test_differentiation(\n    backends,  # the backends you want to compare\n    scenarios;  # the scenarios you defined,\n    correctness=true,  # compares values against the reference\n    type_stability=:none,  # checks type stability with JET.jl\n    detailed=true,  # prints a detailed test set\n)","category":"page"},{"location":"tutorial/#Benchmarking","page":"Tutorial","title":"Benchmarking","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once you are confident that your backends give the correct answers, you probably want to compare their performance. This is made easy by the benchmark_differentiation function, whose syntax should feel familiar:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"df = benchmark_differentiation(backends, scenarios);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The resulting object is a DataFrame from DataFrames.jl, whose columns correspond to the fields of DifferentiationBenchmarkDataRow.","category":"page"}]
}
