```@meta
CollapsedDocStrings = true
```

```@setup backends
using ADTypes, DifferentiationInterface
using DifferentiationInterface.DifferentiationTest: backend_string
import Markdown
import Chairmarks, DataFrames
import Enzyme, FastDifferentiation, FiniteDiff, ForwardDiff, PolyesterForwardDiff, ReverseDiff, Tracker, Zygote

function all_backends()
    return [
        AutoDiffractor(),
        AutoEnzyme(Enzyme.Forward),
        AutoEnzyme(Enzyme.Reverse),
        AutoFastDifferentiation(),
        AutoFiniteDiff(),
        AutoForwardDiff(),
        AutoPolyesterForwardDiff(; chunksize=2),
        AutoReverseDiff(),
        AutoTracker(),
        AutoZygote(),
    ]
end

function all_backends_without_enzyme()
    return filter(all_backends()) do b
        !isa(b, AutoEnzyme)
    end
end
```

# Backends

## Types

Most backend choices are defined by [ADTypes.jl](https://github.com/SciML/ADTypes.jl).

!!! warning
    Only the backends listed here are supported by DifferentiationInterface.jl, even though ADTypes.jl defines more.

```@docs
AutoChainRules
AutoDiffractor
AutoEnzyme
AutoForwardDiff
AutoForwardDiff()
AutoFiniteDiff
AutoPolyesterForwardDiff
AutoPolyesterForwardDiff()
AutoReverseDiff
AutoTracker
AutoZygote
```

We also provide a few of our own:

```@docs
AutoFastDifferentiation
SecondOrder
```

## Availability

You can use [`check_available`](@ref) to verify whether a given backend is loaded, like we did below:

```@example backends
header = "| Backend | available |"  # hide
subheader = "|---|---|"  # hide
rows = map(all_backends()) do backend  # hide
    "| `$(backend_string(backend))` | $(check_available(backend) ? '✓' : '✗') |"  # hide
end  # hide
Markdown.parse(join(vcat(header, subheader, rows...), "\n"))  # hide
```

## [Mutation support](@id backend_mutation_behavior)

All backends are compatible with allocating functions `f(x) = y`.
Only some are compatible with mutating functions `f!(y, x) = nothing`.
You can use [`check_mutation`](@ref) to check that feature, like we did below:

```@example backends
header = "| Backend | mutation |"  # hide
subheader = "|---|---|"  # hide
rows = map(all_backends()) do backend  # hide
    "| `$(backend_string(backend))` | $(check_mutation(backend) ? '✓' : '✗') |"  # hide
end  # hide
Markdown.parse(join(vcat(header, subheader, rows...), "\n"))  # hide
```

## Second order

For second-order differentiation, you can either

- combine a pair `(backend_inner, backend_outer)` of inner and outer backends into a [`SecondOrder`](@ref) object
- use a single backend `backend`, which amounts to `backend_inner = backend_outer = backend`

In Hessian computations, the most efficient combination is often forward-over-reverse, i.e. `SecondOrder(reverse_backend, forward_backend)`.

!!! info
    Many backend combinations will fail for second order.
    Some because of our implementation, and some because the outer backend cannot differentiate through code generated by the inner backend.

You can use [`check_hessian`](@ref) to find working combinations, like we did below (Enzyme was skipped due to compilation time):

```@example backends
header = "| Inner \\ Outer |"  # hide
subheader = "|---|"  # hide
for bo in all_backends_without_enzyme()  # hide
    global header *= " $(backend_string(bo)) |"  # hide
    global subheader *= "---|"  # hide
end  # hide
rows = map(all_backends_without_enzyme()) do bi  # hide
    @info "Generating hessian row for $(backend_string(bi))"  # hide
    row = "| $(backend_string(bi)) |"  # hide
    for bo in all_backends_without_enzyme()  # hide
        row *= " $(check_hessian(SecondOrder(bi, bo)) ? '✓' : '✗') |"  # hide
    end  # hide
    row  # hide
end  # hide
Markdown.parse(join(vcat(header, subheader, rows...), "\n") * "\n")  # hide
```

## Package extensions

```@meta
CurrentModule = DifferentiationInterface
```

Backend-specific extension content is not part of the public API.

```@autodocs
Modules = [
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceChainRulesCoreExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceDiffractorExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceEnzymeExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFastDifferentiationExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceFiniteDiffExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceForwardDiffExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfacePolyesterForwardDiffExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceReverseDiffExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceTrackerExt),
    Base.get_extension(DifferentiationInterface, :DifferentiationInterfaceZygoteExt)
]
Filter = t -> !(t <: ADTypes.AbstractADType)
```
